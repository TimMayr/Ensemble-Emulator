# FDS audio

From [NESdev Wiki](Nesdev_Wiki.xhtml) | View [current version](https://www.nesdev.org/wiki/FDS_audio) | View [other pages](Special_AllPages.xhtml#FDS_audio)

The **Famicom Disk System audio** is an audio channel generated by the 2C33 chip on the [Famicom Disk System](Family_Computer_Disk_System.xhtml "Famicom Disk System")'s RAM card and output through the Famicom cart edge connector's expansion audio pins. 

This channel rapidly repeats a [wavetable](https://en.wikipedia.org/wiki/wavetable_synthesis "wikipedia:wavetable synthesis") set up by the CPU in a manner similar to channel 3 of the Game Boy but with more sophisticated modulation. By changing the waveform, the program can have it simulate many different instruments, such as in the musical game Otocky. 

## Contents

  * 1 Registers
    * 1.1 Master I/O enable ($4023)
    * 1.2 Wavetable RAM ($4040-$407F)
    * 1.3 Volume envelope ($4080)
    * 1.4 Frequency low ($4082)
    * 1.5 Frequency high ($4083)
    * 1.6 Mod envelope ($4084)
    * 1.7 Mod counter ($4085)
    * 1.8 Mod frequency low ($4086)
    * 1.9 Mod frequency high ($4087)
    * 1.10 Mod table write ($4088)
    * 1.11 Wave write / master volume ($4089)
    * 1.12 Envelope speed ($408A)
    * 1.13 Volume gain ($4090)
    * 1.14 Wave accumlator ($4091)
    * 1.15 Mod gain ($4092)
    * 1.16 Mod table address accumulator ($4093)
    * 1.17 Mod counter*gain result ($4094)
    * 1.18 Mod counter increment ($4095)
    * 1.19 Wavetable value ($4096)
    * 1.20 Mod counter value ($4097)
  * 2 Unit tick
    * 2.1 Envelopes
    * 2.2 Modulation unit
    * 2.3 Wave output unit
  * 3 Frequency calculation and timing
    * 3.1 Envelopes
    * 3.2 Wavetables
    * 3.3 Modulation unit
  * 4 Mixing
  * 5 References



## Registers

### Master I/O enable ($4023)

This register must be written to with bit 1 set for the sound registers to function. The FDS bios initializes this by writing $00 followed by $83 to it. 
    
    
    7  bit  0
    ---------
    xxxx xxSD
           ||
           |+- Enable disk I/O registers
           +-- Enable sound I/O registers
    

### Wavetable RAM ($4040-$407F)

The 64-step waveform to be fed to the DAC. Each step consists of an unsigned sample value in the range [0, 63]. However, it cannot be modified unless it is write-enabled, and it cannot be write-enabled while the sound is being played. When writing is disabled ($4089.7), reading anywhere in 4040-407F returns the value at the current wave position. (See also $4089 below.) 
    
    
    7  bit  0  (read/write)
    ---- ----
    OOSS SSSS
    |||| ||||
    ||++-++++- Sample
    ++-------- Returns 01 on read, likely from open bus
    

### Volume envelope ($4080)

The envelope speed is set by this register whether or not the envelope is enabled by the high bit, but the current volume is set only if the high bit is set. 

The volume gain can range from 0 to 63; however, volume values above 32 are clamped to 32 before output. 

Changes to the volume envelope only take effect while the wavetable pointer (top 6 bits of wave accumulator) is 0. The volume envelope is a PWM unit, so apparently (wave_addr==0) is its comparator latch signal. 

However, muting the volume by directly writing volume gain to 0 takes effect immediately. 

Writing to this register immediately resets the clock timer that ticks the volume envelope (delaying the next tick slightly). 
    
    
    7  bit  0  (write; read through $4090)
    ---- ----
    MDVV VVVV
    |||| ||||
    ||++-++++- (M=0) Volume envelope speed
    ||         (M=1) Volume gain and envelope speed.
    |+-------- Volume change direction (0: decrease; 1: increase)
    +--------- Volume envelope mode (0: on; 1: off)
    

### Frequency low ($4082)
    
    
    7  bit  0  (write)
    ---- ----
    FFFF FFFF
    |||| ||||
    ++++-++++- Bits 0-7 of frequency
    

### Frequency high ($4083)

The high bit of this register halts the waveform and resets its phase to 0. Note that if halted it will output the constant value at $4040, and writes to the volume register $4080 or master volume $4089 will affect the output. The envelopes are not ticked while the waveform is halted. 

Bit 6 halts just the envelopes without halting the waveform, and also resets both of their timers. 
    
    
    7  bit  0  (write)
    ---- ----
    MExx FFFF
    ||   ||||
    ||   ++++- Bits 8-11 of frequency
    |+-------- Disable volume and sweep envelopes (but not modulation)
    +--------- When enabled, envelopes run 4x faster. Also stops the mod table accumulator.
    

### Mod envelope ($4084)

The envelope speed is set by this register whether or not the envelope is enabled by the high bit, but the current mod gain is set only if the high bit is set. 

Writing to this register immediately resets the clock timer that ticks the modulator envelope (delaying the next tick slightly). 
    
    
    7  bit  0  (write; read through $4092)
    ---- ----
    MDSS SSSS
    |||| ||||
    ||++-++++- (M=0) Mod envelope speed
    ||         (M=1) Mod gain and envelope speed.
    |+-------- Mod envelope direction (0: decrease; 1: increase)
    +--------- Mod envelope mode (0: on; 1: off)
    

### Mod counter ($4085)

This directly sets the 7-bit signed modulator counter that is otherwise controlled by the mod unit. 

Because the current playback position of the modulator unit is generally hard to predict while active, it is bad practice to write $4085 unless the mod unit is disabled via $4087, because it will generally result in a detuned note. Bio Miracle Bokutte Upa does this, and it requires cycle-accurate timing to emulate correctly. Some emulators incorrectly treat $4085 as a phase-reset for the mod table, which will obviate this timing issue. 

It is generally good practice to write 0 to $4085 to reset the counter after writing the mod table via $4088. 
    
    
    7  bit  0  (write)
    ---- ----
    xBBB BBBB
     ||| ||||
     +++-++++- Mod counter (7-bit signed; minimum $40; maximum $3F)
    

### Mod frequency low ($4086)

If the 12-bit frequency is set to 0, mod table counter is stopped. The freq mod formula of the modulation unit is always in effect, $4084/$4085 still modify the wave frequency. 
    
    
    7  bit  0  (write)
    ---- ----
    FFFF FFFF
    |||| ||||
    ++++-++++- Bits 0-7 of modulation unit frequency
    

### Mod frequency high ($4087)

Setting the high bit of this register halts the mod unit, and allows the mod table to be written via $4088. 

Disabling the mod unit resets its timer accumulator, delaying the first tick after re-enabling. 
    
    
    7  bit  0  (write)
    ---- ----
    HFxx FFFF
    ||   ||||
    ||   ++++- Bits 8-11 of modulation frequency
    |+-------- Force a carry out from bit 11 of mod accumulator. Step every clock.
    +--------- Halt mod table counter. (Freq mod table of modulation unit is always in effect.)
    

On a carry out from bit 11 of the mod, update the mod counter (increment $4085 with mod table). 

### Mod table write ($4088)

This register has no effect unless the mod unit is disabled via the high bit of $4087. 

The mod table is a ring buffer containing 32 entries. Writing to this register replaces an entry at the current mod table playback position with the written value, then advances the playback position to the following entry. 

The position of the mod table actually has 64 steps, but the least significant bit is not used to index the 32 entry table. Each entry will get applied twice as the mod table is stepped through. 

Writing to this register 32 times will effectively reset the phase of the mod table, having advanced the playback position back to its starting point. You should normally always write all 32 entries at once, since the starting write position is not easily predictable. 

Writing $4088 also increments the address (bits 13-17 of wave accumulator) when $4087.7=1. 
    
    
    7  bit  0  (write)
    ---- ----
    xxxx xMMM
          |||
          +++- Modulation input
    

### Wave write / master volume ($4089)

When the high bit is set, the current waveform output is held at its current level until the bit is cleared again. During this time, the wave unit will continue to run, even though the output level is held. 
    
    
    7  bit  0  (write)
    ---- ----
    Wxxx xxVV
    |      ||
    |      ++- Master volume (0: full; 1: 2/3; 2: 2/4; 3: 2/5)
    |          Output volume = current volume (see $4080 above) * master volume
    +--------- Wavetable write enable
               (0: write protect RAM; 1: write enable RAM and hold channel)
    

### Envelope speed ($408A)

This sets a clock multiplier for the volume and modulator envelopes. Few FDS NSFs write to this register. The BIOS initializes this to $E8. 
    
    
    7  bit  0  (write)
    ---- ----
    SSSS SSSS
    |||| ||||
    ++++-++++- Sets speed of volume envelope and sweep envelope
               (0: disable them)
    

### Volume gain ($4090)
    
    
    7  bit  0  (read; write through $4080)
    ---- ----
    OOVV VVVV
    |||| ||||
    ||++-++++- Current volume gain level
    ++-------- Returns 01 on read, likely from open bus
    

### Wave accumlator ($4091)
    
    
    7  bit  0  (read)
    ---- ----
    AAAA AAAA
    |||| ||||
    ++++-++++- Bits 12-19 of the wavetable address accumulator
    

### Mod gain ($4092)
    
    
    7  bit  0  (read; write through $4084)
    ---- ----
    OOVV VVVV
    |||| ||||
    ||++-++++- Current mod gain level
    ++-------- Returns 01 on read, likely from open bus
    

### Mod table address accumulator ($4093)
    
    
    7  bit  0  (read)
    ---- ----
    OAAA AAAA
    |||| ||||
    |+++-++++- Bits 5-11 of the modtable address accumulator
    +--------- Returns 0 on read, likely from open bus
    

### Mod counter*gain result ($4094)

The mod unit uses a sequential multiplier. By reading $4094 at different times, you can see the result. 
    
    
    7  bit  0  (read)
    ---- ----
    MMMM MMMM
    |||| ||||
    ++++-++++- Bits 4-11 of mod counter*gain intermediate result.
    

### Mod counter increment ($4095)

This shows the mod table contents at its current position, translated to mod counter increment value (0,1,2,3,4,5,6,7 ==> 0,1,2,4,C,C,E,F). In other words, what will be added to the counter (sign extend to 7 bits) on the next address tick. 
    
    
    7  bit  0  (read)
    ---- ----
    ???? MMMM
    |||| ||||
    |||| ++++- Next mod counter ($4085) increment.
    ++++------ Unknown counter
    

### Wavetable value ($4096)
    
    
    7  bit  0  (read)
    ---- ----
    OOVV VVVV
    |||| ||||
    ||++-++++- Value at current wavetable position, masked by PWM from volume envelope. (What's being fed to the DAC, probably.)
    ++-------- Returns 01 on read, likely from open bus.
    

### Mod counter value ($4097)
    
    
    7  bit  0  (read)
    ---- ----
    OCCC CCCC
    |||| ||||
    |+++-++++- Current mod counter ($4085) value
    +--------- Returns 0 from read, likely from open bus.
    

## Unit tick

### Envelopes

If enabled, when the volume or mod table envelope is ticked by its timer, it will do one of the following based on $4080/$4084 bit 6: 

  * Increase: if gain is less than 32, increase it by 1
  * Decrease: if gain is more than 0, decrease it by 1



Note that the gains manually can be set higher than 32, but they can no longer be increased at this point. The gain can still be decreased if above 32. 

The volume gain's final output will always be clamped to 32, even though the internal gain can be higher. This is because the pulse width modulation has a period of 32 CPU cycles, and the volume gain is applied as the duty cycle. (32/32 = 100%). 

Otherwise, the volume and mod envelopes are functionally identical. 

Volume gain changes will only take effect when the current wavetable position is 0\. 

### Modulation unit

When the modulation unit is ticked, it advances to the next position in its modulation table according to the address value in its accumulator. 

The modulation unit is ticked every 16 CPU cycles. 

The modulation unit applies the modulation value to the counter when bit 11 of its accumulator carries over (i.e. the first 12 bits gets set back to 0 and bit 12 gets incremented). 

Note that because the least significant bit is not used to index the 32 entry modulation table, the same value will always be written twice on consecutive ticks. 

Each 3-bit value in the mod table corresponds to one of the following adjustment of the mod counter when ticked: 
    
    
    0 = %000 -->  0
    1 = %001 --> +1
    2 = %010 --> +2
    3 = %011 --> +4
    4 = %100 --> reset to 0
    5 = %101 --> -4
    6 = %110 --> -2
    7 = %111 --> -1
    

The mod counter is a signed 7-bit value, and will wrap if overflowed, i.e. 63 + 1 = -64 after wrap, and -64 - 1 = 63. 

The value of the mod counter will modify the pitch of the wave output unit in a complicated way, described by the following C-style code: 
    
    
    // pitch   = $4082/4083 (12-bit unsigned pitch value)
    // counter = $4085 (7-bit signed mod counter)
    // gain    = $4084 (6-bit unsigned mod gain)
    
    // 1. multiply counter by gain
    temp = counter * gain;
    
    // 2. round up to 6 bits only if sign positive (ignoring bit 4)
    if((temp & 0x0f) && !(temp & 0x800))
        temp += 0x20;
    
    // 3. drop 4 bits and center to 0x40
    temp += 0x400;
    temp = (temp >> 4) & 0xff;
    
    // 4. multiply by pitch to get the 20-bit unsigned result
    wave_pitch = (pitch * temp) & 0xFFFFF;
    

### Wave output unit

When this unit is ticked, it advances to the next position in its wave table according to the wave position address value in its accumulator. 

The wave output unit is ticked every 16 CPU cycles. 

## Frequency calculation and timing

### Envelopes

The volume and modulator envelopes tick once after a specific number of CPU cycles, calculated in the following way: 
    
    
    c = CPU clocks per tick
    e = envelope speed ($4080/4084)
    m = master envelope speed ($408A)
    
    c =  8 * (e + 1) * (m + 1)
    

To determine the frequency: 
    
    
    f = frequency of tick
    n = CPU clock rate (≈1789773 Hz)
    
    f = n / c
    

Writing the envelope control registers for these units will reset the timer for the respective unit, meaning that it will next tick **c** cycles after the write. 

### Wavetables

The wave output accumulates a 6-bit wave position address value by adding the 20-bit modulated pitch result to its accumulator every 16 CPU cycles. 
    
    
          ++++++++--------------- 4091 read (bits 12-19)
          ||||||||
    [ AAAAAAXXXXXXXXXXXXXXXXXX ]  Wave accumulator
      ||||||||||||||||||||||||
      ||||++++++++++++++++++++--- +wave_pitch (bits 0-19) add
      ||||||
      ++++++--------------------- wave address (bits 23-18)
    

The initial frequency for wave output **tick** (not period) without modulation can be calculated as follows: 
    
    
    f = frequency of wave table tick
    n = CPU clock rate (≈1789773 Hz)
    p = current pitch value ($4082/$4083)
    
    f = n * p / 16 / 2^12
    

The pitch value for the wave output is **not** simply the 12-bit value from registers $4082/$4083, but is modified by the modulator counter in an obtuse way. See [above](FDS_audio.xhtml#Modulation_unit "FDS audio") for details. 

To calculate the momentary final frequency output: 
    
    
    f = frequency of wave table tick
    n = CPU clock rate (≈1789773 Hz)
    w = wave_pitch as calculated above
    
    f = n * w / 16 / 2^18
    

To calculate for the frequency of the entire **period** , divide the result by 64. 

Disabling the wave unit via the high bit of $4083 immediately resets its accumulator, delaying the next tick after they are enabled again until the next overflow. 

Consequently, this also resets the wave position to 0 (i.e. the $4040 value). 

### Modulation unit

The modulation unit accumulates a 5-bit mod table address value by adding the 12-bit modulation pitch ($4086/$4087) to its accumulator every 16 CPU cycles. 
    
    
              ++++-+++-------- 4093 read
              |||| |||
    [ AAAAA a FFFF ffff ffff ]  Mod accumulator
      ||||| | |||| |||| ||||
      ||||| | |||| ++++-++++-- +freq low (4086[7:0]) add
      ||||| | ++++------------ +freq hi (4087[3:0]) add
      ||||| +----------------- "ghost" modtable address bit(0) makes mod unit step thru each entry twice
      +++++------------------- modtable address
    

The frequency for the modulation unit **tick** (not period) can be calculated as follows: 
    
    
    f = frequency of modulation tick
    n = CPU clock rate (≈1789773 Hz)
    p = current pitch value ($4086/$4087) 
    
    f = n * p / 16 / 2^12
    

To calculate for the frequency of the entire **period** , divide the result by 64. 

Disabling the modulation unit via the high bit of $4087 immediately resets its accumulator, in a similar manner to the wave unit. 

The modulation table position address (bits 13-17) however does not reset. 

## Mixing

The current wave output value is attenuated by the current volume gain and master volume. This output signal is affected by a filter that attenuates higher frequencies. This filter can be approximated as a 1-pole lowpass with a cutoff of ~2000Hz. 

The maximum volume of the FDS signal on a Famicom is roughly 2.4x the maximum volume of the APU square, and the polarity is the same as the 2A03. On other machines, such as the Twin Famicom, the output may be significantly louder. 

The DAC output of the waveform is 6-bits (0-63), and ideally should be linear, but recent tests have revealed jagged discontinuities at binary nodes. (More works needs to be done to measure this effect.) 

The volume is applied by a pulse width modulation every 32 CPU cycles. The duty cycle is controlled by the volume gain (volume gain / 32). Because this modulation is above the audible threshold (55.930 kHz), it may be emulated simply as a linear volume control. 

## References

  * [Modulator unit notes](https://forums.nesdev.org/viewtopic.php?p=232662#p232662) by Loopy
  * [FDS decap DAC schematics](https://forums.nesdev.org/viewtopic.php?t=25226) from Yuri213212
  * [FDS output notes](https://forums.nesdev.org/viewtopic.php?f=3&t=10233) (from forums)
  * [FDS Sound](https://nesdev.org/FDS.txt) by Disch
  * [Famicom Disk System technical reference](https://nesdev.org/FDS%20technical%20reference.txt) by Brad Taylor
  * [US Patent 4783812 on the FDS sound system](https://nesdev.org/4783812-sound_synth.pdf)



Categories: [Expansion audio](Category_Expansion_audio.xhtml)
