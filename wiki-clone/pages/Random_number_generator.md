# Random number generator

From [NESdev Wiki](Nesdev_Wiki.xhtml) | View [current version](https://www.nesdev.org/wiki/Random_number_generator) | View [other pages](Special_AllPages.xhtml#Random_number_generator)

While truly random numbers are difficult to create with a deterministic computer, a **pseudorandom number generator** , or **PRNG** , may be used instead, which is technically deterministic, but designed so that the output should appear consistently uncorrelated. There are a wide variety of suitable algorithms. 

Typically a starting "seed" is supplied by the program to begin the sequence generated by a PRNG. By finding some way[1] of gathering a suitably unpredictable starting seed, (e.g. counting the time until the user presses a button) the program can start at a different part of the sequence each time it is run, ensuring the user does not have the same experience twice. 

## Contents

  * 1 Linear feedback shift register
    * 1.1 Simple
    * 1.2 Overlapped
  * 2 See also
  * 3 References
  * 4 External references



## Linear feedback shift register

The [linear feedback shift register](https://en.wikipedia.org/wiki/Linear_feedback_shift_register) is commonly used as a PRNG on systems like the 6502 which have no hardware multiply capabilities. This rotates a series of bits (the _shift register_), with the bit coming off the end of the series _feeding back_ into the register as an exclusive-OR operation. By choosing the feedback bits carefully, this can create a sequence that fills the register with every possible value (except 0), allowing relatively long random number sequences using only bitwise operations. 

This example[2] is only 16 bits wide, but the sequence length of an LSFR can be doubled with each additional bit. 

If you need to generate large batches of random numbers at once, a [24 or 32-bit LFSR](Random_number_generator_Linear_feedback_shift_register__advanced_.xhtml#Overlapped_24_and_32_bit_LFSR "Random number generator/Linear feedback shift register \(advanced\)") is recommended. Wider LFSRs are still very practical, and produce extremely long random number sequences. Narrower LFSRs are also possible, but not generally recommended due to their short, repetitive sequences. 

See [Linear feedback shift register (advanced)](Random_number_generator_Linear_feedback_shift_register__advanced_.xhtml "Random number generator/Linear feedback shift register \(advanced\)") for further commentary on this code, and various alternatives with other LFSR widths and properties (efficiency, quality, etc.). 

### Simple
    
    
    ; prng
    ;
    ; Returns a random 8-bit number in A (0-255), clobbers Y (0).
    ;
    ; Requires a 2-byte value on the zero page called "seed".
    ; Initialize seed to any value except 0 before the first call to prng.
    ; (A seed value of 0 will cause prng to always return 0.)
    ;
    ; This is a 16-bit Galois linear feedback shift register with polynomial $0039.
    ; The sequence of numbers it generates will repeat after 65535 calls.
    ;
    ; Execution time is an average of 125 cycles (excluding jsr and rts)
    
    .zeropage
    seed: .res 2       ; initialize 16-bit seed to any value except 0
    
    .code
    prng:
    	ldy #8     ; iteration count (generates 8 bits)
    	lda seed+0
    :
    	asl        ; shift the register
    	rol seed+1
    	bcc :+
    	eor #$39   ; apply XOR feedback whenever a 1 bit is shifted out
    :
    	dey
    	bne :--
    	sta seed+0
    	cmp #0     ; reload flags
    	rts
    

19 bytes, 133-141 cycles per call (average 137). 

### Overlapped

This is equivalent to the simple version above, but performs 8 iterations at once in a complex overlapped operation. 
    
    
    ; Returns a random 8-bit number in A (0-255), clobbers Y (unknown).
    prng:
    	lda seed+1
    	tay ; store copy of high byte
    	; compute seed+1 ($39>>1 = %11100)
    	lsr ; shift to consume zeroes on left...
    	lsr
    	lsr
    	sta seed+1 ; now recreate the remaining bits in reverse order... %111
    	lsr
    	eor seed+1
    	lsr
    	eor seed+1
    	eor seed+0 ; recombine with original low byte
    	sta seed+1
    	; compute seed+0 ($39 = %111001)
    	tya ; original high byte
    	sta seed+0
    	asl
    	eor seed+0
    	asl
    	eor seed+0
    	asl
    	asl
    	asl
    	eor seed+0
    	sta seed+0
    	rts
    

35 bytes, 69 cycles. 

## See also

  * [Least recently used](Least_recently_used.xhtml "Least recently used")
  * [Linear feedback shift register (advanced)](Random_number_generator_Linear_feedback_shift_register__advanced_.xhtml "Random number generator/Linear feedback shift register \(advanced\)")



## References

  1. ↑ [Forum discussion of obscure methods of gathering seed entropy.](https://forums.nesdev.org/viewtopic.php?p=107596#p107596)
  2. ↑ [prng_6502: a Galois LSFR RNG](https://github.com/bbbradsmith/prng_6502)



## External references

  * [CC65's rand.s](https://github.com/cc65/cc65/blob/master/libsrc/common/rand.s) (a good quality 32-bit LCG, [forum commentary](http://forums.nesdev.org/viewtopic.php?f=2&t=14499))
  * nesdev forum: [Which randomizer to use?](http://forums.nesdev.org/viewtopic.php?f=2&t=13172)
  * nesdev forum: [need assistance with random number generator](http://forums.nesdev.org/viewtopic.php?f=10&t=11241)
  * nesdev forum: [CRC routines as PRNGs](http://forums.nesdev.org/viewtopic.php?f=2&t=9598)
  * [Codebase64.org PRNG code examples](http://codebase64.org/doku.php?id=base:6502_6510_maths#random_numbers)


