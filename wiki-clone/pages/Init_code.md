# Init code

From [NESdev Wiki](Nesdev_Wiki.xhtml) | View [current version](https://www.nesdev.org/wiki/Init_code) | View [other pages](Special_AllPages.xhtml#Init_code)

When the NES is powered on or reset, the program should do the following within a fixed bank: 

  * Set IRQ ignore bit (not strictly necessary as the 6502 sets this flag on all interrupts, including RESET, but it allows program code to simulate a reset by `JMP ($FFFC)`)
  * Disable decimal mode (not strictly necessary as the 2A03 has no decimal mode, but it maintains compatibility with generic 6502 debuggers)
  * Disable [PPU](PPU.xhtml "PPU") NMIs and rendering (in case the program is running on a Famicom or a top-loading NES, where pressing the Reset button does **not** reset the PPU to its [power up state](PPU_power_up_state.xhtml "PPU power up state"))
  * Disable [IRQs](IRQ.xhtml "IRQ") generated by the [APU Frame Counter](APU_Frame_Counter.xhtml "APU Frame Counter") (**enabled at power-up**) and [APU DMC](APU_DMC.xhtml "APU DMC") [[1]](http://forums.nesdev.org/viewtopic.php?p=22538#p22538)
  * Initialize stack pointer
  * Initialize the mapper (if any)



The init code after this point may be placed either in the fixed bank or in a separate bank using a bankswitch followed by a `JMP`: 

  * Set all RAM that your program uses to a known state. This often involves clearing internal RAM (@ $0000-$07FF) (and PRG RAM if needed (@ $6000-$7FFF)), except that which is intended to survive a reset (such as high scores). However, you don't need to set up an area of RAM that only one part of a program uses; you can set that in the same part where it's used, and in many cases, you'll need to set it up multiple times as part of the program is run multiple times.
  * Wait at least 30,000 cycles (in case the program is running on a front-loading NES - see [PPU power up state](PPU_power_up_state.xhtml "PPU power up state")) before reading or writing registers $2003 through $2007. This is commonly done by waiting for the PPU to signal the start of vertical blank twice through $2002.



Some mappers have no fixed bank because they switch all 32 KB of PRG at a time. These include [AxROM](AxROM.xhtml "AxROM"), [BxROM](BNROM.xhtml "BxROM"), [GxROM](GxROM.xhtml "GxROM"), and some configurations of [MMC1](MMC1.xhtml "MMC1"). You'll have to put the interrupt vectors and the code up to the end of the `JMP` in a separate section that is duplicated in each bank. Often, the 256-byte page $FF00-$FFFF contains the vectors, the start of the init code, and a "trampoline" for jumps from code in one bank to code in another. 

Sample implementation: 
    
    
    reset:
        sei        ; ignore IRQs
        cld        ; disable decimal mode
        ldx #$40
        stx $4017  ; disable APU frame IRQ
        ldx #$ff
        txs        ; Set up stack
        inx        ; now X = 0
        stx $2000  ; disable NMI
        stx $2001  ; disable rendering
        stx $4010  ; disable DMC IRQs
    
        ; Optional (omitted):
        ; Set up mapper and jmp to further init code here.
    
        ; The vblank flag is in an unknown state after reset,
        ; so it is cleared here to make sure that @vblankwait1
        ; does not exit immediately.
        bit $2002
    
        ; First of two waits for vertical blank to make sure that the
        ; PPU has stabilized
    @vblankwait1:  
        bit $2002
        bpl @vblankwait1
    
        ; We now have about 30,000 cycles to burn before the PPU stabilizes.
        ; One thing we can do with this time is put RAM in a known state.
        ; Here we fill it with $00, which matches what (say) a C compiler
        ; expects for BSS. Since we haven't modified the X register since
        ; the earlier code above, it's still set to 0, so we can just
        ; transfer it to the Accumulator and save a byte
        txa
    @clrmem:
        sta $00,x
        sta $100,x
        sta $200,x
        sta $300,x
        sta $400,x
        sta $500,x
        sta $600,x
        sta $700,x
        inx
        bne @clrmem
    
        ; Other things you can do between vblank waits are set up audio
        ; or set up other mapper registers.
       
    @vblankwait2:
        bit $2002
        bpl @vblankwait2
    

At this point, the program can fill the [nametables](PPU_nametables.xhtml "PPU nametables"), fill the [pattern tables](PPU_pattern_tables.xhtml "PPU pattern tables") (if the board uses CHR RAM), fill the [palette](PPU_palettes.xhtml "PPU palettes"), and start displaying things. 

Notes on the **clrmem** loop: 

  * One of the pages of RAM will normally be reserved for an [OAM buffer](PPU_OAM.xhtml "PPU OAM") (often $200-$2FF), and values of $00 will place all sprites in the top left corner. We may wish to initialize this page separately with $FF or some other suitable value to start with all sprites offscreen.
  * If it is desired that some RAM state will persist across reset, we would also need to find some way to prevent clearing the persistent portion here.



## See also

  * [APU basics](APU_basics.xhtml "APU basics") covers how to initialize the APU


